# -*- coding: utf-8 -*-
"""Projeto_-_Logica_de_programacao_I - Criptografia_grupo3_1106_TiagoMarto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/184aW9bW2_t5VaZo-7qgyaGMiDSAQFFAs

# Codificação e decodificação de mensagens com Python

## Contextualização

A PyCoders Ltda., cada vez mais especializada no mundo da Inteligência Artificial e Ciência de Dados, foi procurada por uma fintech para desenvolver um projeto codificação de dados.

A fintech percebeu que muitas das informações usadas na área de inteligência de negócios, estão sendo roubadas por uma empresa concorrente!

Para lidar com esse problema, um dos funcionários sugeriu que os dados sejam codificados usando uma chave secreta, e unicamente quem souber a chave secreta poderá conseguir decodificar a mensagem e visualizar os dados originais.

Como existe muito risco de a chave vazar e de qualquer forma os dados serem roubados, a chave tem que ser alterada com frequência, fazendo desta forma que a codificação seja dependente da senha!

Por exemplo:

Se eu tiver a mensagem: 'Hello world!'
- A mensagem codificada com uma chave aleatória X, poderia ser: ```'bdgdjh3bvd8397'```

- E, a mesma mensagem codificada com uma chave aleatória Y, poderia ser: ```'oouyrjrhyw26'```

## Obejtivo de projeto

O objetivo deste projeto é codificar e decodificar mensagens usando uma chave comum.

1. Neste projeto, os usuários devem inserir a mensagem para codificar ou decodificar.
2. Os usuários devem selecionar o modo para escolher o processo de codificação e decodificação.
3. A mesma chave deve ser usada para processar a codificação e decodificação da mesma mensagem.

ATENÇÃO: Considerar que duas chaves diferentes devem gerar, _em geral_, codificações e/ou decodificações diferentes!

## Exemplo:

1. O sistema deve perguntar ao usuário se deseja codificar ou decodificar a mensagem, ou se deseja sair do processo.

2. Se o usuário selecionou que deseja codificar ou decodificar, o sistema agora deve solicitar ao usuário que informe:

- Caso for selecionado codificar: o sistema deve pedir para o usuário colocar a frase a ser codificada.
- Caso for selecionado decodificar: o sistema deve pedir para o usuário colocar a frase a ser decodificada.

3. Uma vez informada a frase (a codificar ou codificada), o sistema deve pedir para o usuário informar a chave secreta.

4. Uma vez que o sistema receba a chave, deve mostrar a mensagem codificada ou decodificada.

5. Finalmente o sistema deve voltar a etapa 1.
"""

# Exemplo codificação:
mensagem = 'Jorge'
chave = '123'

# Criterio de codificacao naive: colocar a chave entre as letras originais
mensagem_codificada = 'J123o123r123g123e'

# Para decodificação:
mensagem_codificada = 'J123o123r123g123e'
chave = '123'

mensagem_decodificada = 'Jorge'

"""### Considerações importantes:

1. É obrigatorio garantir que vamos conseguir decodificar uma mensagem codificada.
2. A chave pode ser quaquer uma, ou seja: combinação de números, letras e carateres especiais.
3. Faça vários testes, e identifique situações nas quais seu algoritmo vai ter mais dificuldade, e a partir disso pense em melhorias a serem feitas no seu algoritmo.
4. Aplique todos os conteúdos aprendidos durante esse módulo para a entrega deste projeto.
5. Está proibido o uso de bibliotecas do python que já realizem codificação e decodificação de mensagens.

### Organização e entregáveis

1. O projeto pode ser feito em grupo de até 05 participantes.
2. O projeto completo (Notebook, código-fonte, link para fontes, bases e demais artefatos) deve ser enviado via git (do professor) com nome dos participantes.

Boa sorte e divirta-se!!

**===========================================================================
**

Professor:

* Tiago Marto

Alunos:
* Jennifer Silva
* Isabele Teixeira
* Linda Ramos
* Paulo Jennings
* Tácito Ferreira.
* Antônio Sousa

Na implementação da criptografia, utilizamos duas técnicas simples: O exemplo demostrado no escopo do projeto, inserir a chave entre os caracteres da mensagem e, também nos inspiramos na Cifra de César, porém adaptada para receber caracteres especiais e letras acentuadas, englobando toda a parte dos caracteres imprimíveis da tabela ASCII. O código, ao calcular aposição do caractere a ser retornado, varia no intervalo compreendido entre 32 a 255 na tabela.  

Contextualizando.

No escopo do projeto é citado o termo "Critério de codificação naive". Esse termo quer dizer simples, ou ingênuo. Como o exemplo utilizado de colocar a chave entre as letras originais da mensagem.

Em criptografia, a Cifra de César, também conhecida como cifra de troca, código de César ou troca de César, é uma das mais simples e conhecidas técnicas de criptografia. É um tipo de cifra de substituição na qual cada letra do texto é substituída por outra, que se apresenta no alfabeto abaixo dela um número fixo de vezes. Por exemplo, com uma troca de três posições, A seria substituído por D, B se tornaria E, e assim por diante. O nome do método é em homenagem a Júlio César, que o usou para se comunicar com os seus generais.

O processo de criptografia de uma cifra de César é frequentemente incorporado como parte de esquemas mais complexos, como a cifra de Vigenère, e continua tendo aplicações modernas, como no sistema ROT13. Como todas as cifras de substituição monoalfabéticas, a cifra de César é facilmente decifrada e na prática não oferece essencialmente nenhuma segurança na comunicação.


by:
https://pt.wikipedia.org/wiki/Cifra_de_C%C3%A9sar
"""

#   O programa começa definindo duas listas vazias, que servem para criar um banco
# de dados com as mensagens e chaves enquanto o programa roda. Nesta versão, quando
# o programa para, as mensagens se perdem. Isso serve para demonstrar que se a
# mensagem e a chave não estiverem no banco, retornará uma mensagem de erro.

mensagens_codificadas = []
chaves = []

# O próximo trecho cria uma função chamada codificar que recebe dois parâmetros, mensagem e chave, respectivamente.

# Função para codificar a mensagem
def codificar(mensagem, chave):

# -------------------------------------------------------------------------
# Primeiro, a função transforma a variável mensagem em uma lista e cria uma
# variável string vazia que servirá para guardar os caracteres codificados.
# -------------------------------------------------------------------------

  lista_mensagem = list(mensagem)
  lista_caractere_codificado = ''

# -------------------------------------------------------------------------
#   A próxima trecho contém um loop for no tamanho da lista de mensagens,
# que faz o seguinte:
#   A variável codigo_caractere recebe o valor numérico da posição do caractere
# na tabela ASCII, e para isso, utiliza-se a função ord().

#   A variável codigo_caractere_codificado recebe valores numéricos de caracteres
# seguindo esta lógica: o valor numérico do caractere é subtraído do valor do caractere 'espaço' (ord('espaço') = 32,
# usado como ponto de referência zero para o deslocamento). Em seguida, o tamanho da chave é somado a essa diferença.
# O resultado é calculado com o operador de módulo (% 224) para garantir que o
# deslocamento permaneça dentro do intervalo desejado entre 32 e 224,
# caso a chave seja maior que o módulo. Esse intervalo abrange caracteres alfabéticos (maiúsculos e minúsculos),
# caracteres acentuados e outros caracteres especiais da Tabela ASCII.
# Para finalizar, o valor numérico do espaço é adicionado novamente para obter a posição do caractere codificado.
#   A variável lista_caractere_codificado guarda os resultados codificados já em
# forma de caractere. Isso é feito com a função chr(), que com base em um valor
# numérico, retorna o caractere correspondente na Tabela ASCII.
# --------------------------------------------------------------------------

  for caractere in range(len(lista_mensagem)):
    codigo_caractere = ord(lista_mensagem[caractere])
    codigo_caractere_codificado = (codigo_caractere - ord(' ') + len(chave)) % 224 + ord(' ')
    lista_caractere_codificado += chr(codigo_caractere_codificado)

# --------------------------------------------------------------------------
#   Agora começa a criação da variável lista_chave que recebe a string da chave e a
# transforma em uma lista. Também é criada uma variável lista_chave_codificado que
# recebe uma string vazia e que posteriormente receberá os caracteres da chave codificados.
# --------------------------------------------------------------------------

  lista_chave = list(chave)
  lista_chave_codificado = ''

# --------------------------------------------------------------------------
#   O loop for no tamanho da lista_chave segue a mesma lógica do loop feito para a mensagem.
# --------------------------------------------------------------------------

  for caractere in range(len(lista_chave)):
    codigo_caractere = ord(lista_chave[caractere])
    codigo_caractere_codificado = (codigo_caractere - ord(' ') + len(chave)) % 224 + ord(' ')
    lista_chave_codificado += chr(codigo_caractere_codificado)

# -------------------------------------------------------------------------
#   Neste trecho, O loop for no tamanho da lista_mensagem é usado para inserir a chave codificada na mensagem e é guardada
# na variável lista_mensagem. A variável str_mensagem recebe a mensagem codificada
# transformada de uma lista de strings em uma única string, para isso utiliza-se o método join().
# -------------------------------------------------------------------------

  for i in range(len(lista_mensagem)):
    lista_mensagem[i] = lista_caractere_codificado[i] + lista_chave_codificado
  str_mensagem = ('').join(lista_mensagem)

# -------------------------------------------------------------------------
#   Neste trecho, respectivamente, mensagem e chave codificadas, são guardadas nas variáveis
# mensagens_codificadas e chaves, para isso, utiliza-se o método .append().
# Aqui entende-se como a criação de um "banco", usando listas para isso.
# -------------------------------------------------------------------------

  mensagens_codificadas.append(str_mensagem)
  chaves.append(chave)

  return str_mensagem

# -------------------------------------------------------------------------
# Fim da primeira função codificar.
# -------------------------------------------------------------------------

# Função decodificar.

# Segue a mesma lógica da função codificar com algumas pequenas diferenças.

def decodificar(mensagem, chave):

# -------------------------------------------------------------------------
# Neste Trecho é feita a verificação se as mensagens e chaves estão no "banco",
# e se caso um dos parâmetros, ou ambus, não existirem no "banco", retorna mensagem de erro.
# -------------------------------------------------------------------------

  if mensagem not in mensagens_codificadas:
    return "Mensagem codificada não encontrada, verifique a mensagem que deseja decodificar e tente novamente!"

  index = mensagens_codificadas.index(mensagem)
  if chave != chaves[index]:
        return "Chave incorreta! A mensagem não pode ser decodificada."

#--------------------------------------------------------------------------

  lista_mensagem = list(mensagem)
  lista_chave = list(chave)
  lista_caractere_codificado = ''

# -------------------------------------------------------------------------
#   A principal diferença é que, como a mensagem codificada é uma única
# string que contém mensagem e chave concatenadas, a decodificação é realizada em um único loop for.

#   No trecho que desloca o caractere:
#
# -->>codigo_caractere_codificado = (codigo_caractere - ord(' ') + len(chave)) % 224 + ord(' ')<<--
#
#   A primeira operação soma é substituída pela operação de subtração. Isso ocorre porque,
# enquanto na codificação o caractere é deslocado para a frente, na decodificação
# ele é deslocado para trás. O restante do processo é semelhante,
# incluindo a aplicação do módulo % 224 e a adição do valor ord(' ') para obter
# o caractere decodificado.
# -------------------------------------------------------------------------

  for caractere in range(len(lista_mensagem)):
    codigo_caractere = ord(lista_mensagem[caractere])
    codigo_caractere_codificado = (codigo_caractere - ord(' ') - len(chave)) % 224 + ord(' ')
    lista_caractere_codificado += chr(codigo_caractere_codificado)

  # -------------------------------------------------------------------------
  # Em seguida, há a concatenação da lista de strings em uma única string e
  # a remoção da chave de dentro da mensagem, utilizando a função .replace()
  # -------------------------------------------------------------------------

  mensagem = ('').join(lista_caractere_codificado)
  mensagem_decodificada = mensagem.replace(chave,'')
  return mensagem_decodificada

# -------------------------------------------------------------------------
# FIm da segunda função (decodificar)
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# Inputs do Usuário:
# -------------------------------------------------------------------------

#   O programa inicia com um menu.
#   Um loop while é utilizado para mostrar o menu. O programa roda
# até que o usuário escolha a opção "3" para encerrar.

#   Se a escolha for "1" para codificar, o usuário é solicitado a inserir a
# mensagem e, em seguida, a chave. A função codificar é utilizada para cifra a mensagem.

#   Se a escolha for "2" para decodificar, o usuário insere a mensagem codificada e,
# em seguida, a chave, que não precisa estar codificada. A função decodificar
# é utilizada, e o resultado é a mensagem conforme foi originalmente escrita.

while True:
    print('='*100)
    print("\nSelecione a opção:\n")
    print("1. Codificar mensagem")
    print("2. Decodificar mensagem")
    print("3. Sair")
    opcao = input("\nDigite o número da opção desejada: ")

    if opcao == "1":
        mensagem = input("\nDigite a mensagem a ser codificada: ")
        chave = input("\nDigite a chave secreta: ")
        print("\nMensagem codificada:", codificar(mensagem, chave))
    elif opcao == "2":
        mensagem = input("\nDigite a mensagem a ser decodificada: ")
        chave = input("\nDigite a chave secreta: ")
        print("\nMensagem decodificada:", decodificar(mensagem, chave))
    elif opcao == "3":
        break
    else:

        print(f'\n{"X"*34} Opção inválida. Tente novamente {"X"*34}\n')

print('\nPrograma encerrado.')

# -------------------------------------------------------------------------
# Informações adicionais.
# -------------------------------------------------------------------------
# ord() retorna o valor numérico correspondente à posição de um caractere na tabela ASCII. Exemplo: numero_caractere = ord('A') retorna 65.
# chr() retorna o caractere na posição equivalente ao número. Exemplo: caractere_numero = chr(65) retorna 'A'.
#
# https://pythoniluminado.netlify.app/strings
# -------------------------------------------------------------------------
#
# -------------------------------------------------------------------------
# * metodo join() usado na concatenação de strings.
#
# list1 = ['1','2','3','4']
#
# s = "-"
# s = s.join(list1)
# print(s)
#
# type(s)
#
# Resultada:
# 1-2-3-4
# str
# https://acervolima.com/funcao-join-em-python/
# -------------------------------------------------------------------------
#
# -------------------------------------------------------------------------
# Método replace()
# Substitui substring por outra.
#
# Em Python, usamos o método replace, que recebe dois argumentos. Seja texto a string:
# texto.replace(nova,antiga)
#
# Ou seja, toda vez que achar a substring antiga ele vai colocar a substring nova, na string texto.
# Esse método retorna uma nova string, com o texto substituto.
#
# O código, bem simples de ser entendido, é:
#
# texto = input("O que acha do curso: " )
# texto=texto.replace('Pyton','Python')
# texto=texto.replace('eh','é')
# print("Texto corrigido    :",texto)
#
#resultado:
# O que acha do curso: Pyton eh legal
# Texto corrigido    : Python é legal
#
# https://www.pythonprogressivo.net/2018/11/Localizar-Substituir-substring-Strings.html
# -------------------------------------------------------------------------
#
# -------------------------------------------------------------------------
#   Link vídeo sobre Aritmética Modular "COMO FUNCIONA A ARITMÉTICA MODULAR?",
# de autoria do canal Pitagóricos e apresentado por Giovana Cunha.
# O vídeo serviu como base de conhecimento para desenvolver o código.
# https://www.youtube.com/watch?v=huD7-Fe-Z_A&t=512s
# -------------------------------------------------------------------------